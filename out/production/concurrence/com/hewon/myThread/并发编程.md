### 并发编程
### 第一部分
>```markdown
>线程的生命周期
>   1. 阻塞
>   2. 就绪
>   3. 运行
>   4. 中断
>       Java中的线程中断是一种线程间的协作模式，被中断的线程根据中断状态进行自行处理
>       线程睡眠期间其他线程调用该线程的interrupt()方法中断该线程，会在sleep处抛出中断异常
>相关API
>   1. 阻塞
>   2. 就绪
>   3. 运行
>   4. 中断
>       void interrupt()        主动调用线程将目标线程的中断标志位标记为True
>       boolean isInterrupted() 检测当前线程是否被中断，不重置中断标志(ClearInterrupted)
>       boolean interrupted()   检测当前线程是否被中断，重置中断标志(ClearInterrupted)
>```
>```markdown
>上下文切换
>   当前线程使用完时间片后，就会处于就绪状态并让出CPU让其他线程占用，这就是上下文切换，从当前线程的上下文切换到了其他线程。
>   线程上下文切换时机有：当前线程的CPU时间片使用完处于就绪状态时，当前线程被其他线程中断时。
>```

>```markdown
>线程死锁
>   死锁是指两个或两个以上的线程在执行过程中，因争夺资源而造成的互相等待的现象，在无外力作用的情况下，这些线程会一直相互等待而无法继续运行下去
>   1. 互斥条件：指线程对己经获取到的资源进行排它性使用，即该资源同时只由一个线程占用。如果此时还有其他线程请求获取该资源，则请求者只能等待，直至占有资源的线程释放该资源。
>   2. 请求并持有条件：指一个线程己经持有了至少一个资源，但又提出了新的资源请求，而新资源己被其他线程占有，所以当前线程会被阻塞，但阻塞的同时并不释放自 己己经获取的资源。
>   3. 不可剥夺条件：指线程获取到的资源在自己使用完之前不能被其他线程抢占，只有在自己使用完毕后才由自己释放该资源。
>   4. 环路等待条件：指在发生死锁时，必然存在一个线程→资源的环形链。
>破坏线程死锁   
>   1. 避免死锁的核心在于破坏现有条件，实际上只有请求并持有以及环路等待可以被破坏，实际上仔细考虑我们可以发现通过调整资源的请求顺序可以避免死锁情况的出现
>   2. 多线程在获取资源时，对于多线程均需要的资源可以进行排序，所有线程仅在获取了资源n-1时才能获取资源n，比如线程First获取资源1后线程Second无法获取资源1此时陷入阻塞状态
>      线程First继续获取资源2，以此类推知道线程First获取资源n后使用完毕并释放资源n后进行依次释放资源知道释放资源1，此时其他的线程都阻塞在对资源1的获取上，通过线程调度算法选择线程进行资源分配
>```

>```markdown
>守护线程和用户线程
>   1. daemon线程
>       守护线程的结束不影响JVM的退出
>   2. user线程
>       用户线程没有全部结束的情况下，JVM无法退出

>```

### 第二部分
>```markdown
>   1. 阻塞
>   2. 就绪
>   3. 运行
>相关API
>   1. 阻塞
>   2. 就绪
>   3. 运行